

# ADR-0005: Client-side Routing as a First-Class Architectural Principle

## Status
Accepted

## Date
2026-02-05

## Context

As the RAGfish ecosystem evolved into a multi-layered system consisting of a Client application (Noesis Noema), an Execution layer (noema-agent), and a Knowledge layer (RAGpack), the question of **where routing and policy decisions should reside** became critical.

Routing decisions include, but are not limited to:
- Whether a request is executed locally or via a remote service
- Which execution resource is invoked
- Cost, latency, privacy, and reliability trade-offs
- Human approval or intervention thresholds

A naive design would place these decisions on the server or execution layer. However, this approach introduces systemic risks that conflict with the Architecture Constitution (ADR-0004).

Specifically, server-side routing leads to:
- Implicit delegation of decision authority to AI-controlled systems
- Reduced transparency for users
- Tight coupling between policy and execution
- Slower evolution due to centralized control

## Decision

All routing and policy decisions are designated as **Client-side responsibilities** and are treated as a first-class architectural principle.

Formally:

- The Client layer (e.g. Noesis Noema) is solely responsible for:
  - Routing decisions
  - Policy evaluation (privacy, cost, latency)
  - Execution placement (local vs cloud)
  - Human-in-the-loop checkpoints

- The Execution layer (noema-agent) is strictly limited to:
  - Constrained execution of explicit requests
  - Stateless or bounded-state reasoning
  - Tool invocation as instructed

- The Knowledge layer (RAGpack) remains:
  - Passive
  - Model-agnostic
  - Free of behavioral or policy logic

This decision is **permanent** and applies to all current and future implementations within the RAGfish ecosystem.

## Rationale: Why NOT Server-side Routing

### 1. Accountability

Routing decisions materially affect cost, privacy, and outcomes.

Delegating these decisions to server-side systems would implicitly shift responsibility away from humans, violating the principle that **only humans are accountable actors**.

### 2. Inspectability

Client-side routing ensures that decision logic remains:
- Observable
- Auditable
- Modifiable by humans

Server-side routing obscures decision paths behind opaque services, undermining trust and verification.

### 3. Coupling

Embedding routing logic in the execution layer creates tight coupling between:
- Policy
- Infrastructure
- Model behavior

This coupling reduces replaceability and increases long-term maintenance risk.

### 4. Evolution Speed

Routing policies evolve faster than execution infrastructure.

Placing routing at the Client layer allows rapid iteration without destabilizing execution services or violating compatibility guarantees.

## Consequences

### Positive
- Clear human accountability
- Strong alignment with the Architecture Constitution
- Decoupled execution services
- Improved auditability and governance

### Trade-offs
- Increased complexity at the Client layer
- Potential duplication of routing logic across clients

### Mitigations
- Shared routing libraries
- Policy expressed as data rather than code
- Explicit feedback channels from execution to client

## References

- ADR-0004: Architecture Constitution
- ARCHITECTURE.md (Client Layer responsibilities)
- Canonical Horizontal Architecture Diagram
